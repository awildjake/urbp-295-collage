<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Georeferencing Tool - With Reference Overlays</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(44, 62, 80, 0.95);
            color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            z-index: 1000;
            max-width: 350px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #controls h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .control-row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        input[type="file"] {
            padding: 5px;
            background: white;
            border: none;
            border-radius: 3px;
            font-size: 12px;
        }
        
        input[type="number"], input[type="range"] {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            width: 100px;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        button.danger {
            background: #e74c3c;
        }
        
        button.danger:hover {
            background: #c0392b;
        }
        
        button.success {
            background: #27ae60;
            font-size: 12px;
            padding: 6px 12px;
        }
        
        button.success:hover {
            background: #229954;
        }
        
        #map {
            width: 100%;
            height: 100vh;
        }
        
        #coordinates-output {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(52, 73, 94, 0.95);
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            z-index: 1000;
        }
        
        .copy-button {
            background: #27ae60;
            font-size: 16px;
            padding: 10px 20px;
        }
        
        .copy-button:hover {
            background: #229954;
        }
        
        .instructions {
            background: #f39c12;
            color: white;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 3px;
            font-size: 13px;
        }
        
        .reference-info {
            background: #16a085;
            color: white;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 3px;
            font-size: 12px;
        }
        
        /* Image overlay styling */
        .image-overlay-container {
            position: absolute;
            pointer-events: none;
            z-index: 400;
        }
        
        .image-overlay-container.draggable {
            pointer-events: auto;
            cursor: move;
        }
        
        .image-overlay-container img {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .corner-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #e74c3c;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            z-index: 1000;
            margin-left: -10px;
            margin-top: -10px;
        }
        
        .corner-handle:hover {
            background: #c0392b;
            transform: scale(1.2);
        }
        
        .corner-handle.nw { cursor: nw-resize; }
        .corner-handle.ne { cursor: ne-resize; }
        .corner-handle.sw { cursor: sw-resize; }
        .corner-handle.se { cursor: se-resize; }
        
        /* Reference overlays styling */
        .reference-overlay {
            opacity: 0.6;
            pointer-events: none;
        }
        
        /* From index.css - for interactive overlays */
        .custom-overlay-shadow {
            filter: drop-shadow(2px 2px 2px rgba(212, 217, 101, 0.8));
            transition: filter 0.3s ease;
        }
        
        .custom-overlay-shadow:hover {
            filter: drop-shadow(0 0 20px rgba(212, 217, 101, 0.8)) drop-shadow(8px 8px 2px rgba(0, 0, 0, 0.9));
        }
        
        .toggle-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        .toggle-section h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #d4d965;
        }
        
        .leaflet-tooltip {
            background: rgba(212, 217, 101, 0.9);
            color: black;
            font-weight: bold;
            border: 2px solid black;
            padding: 5px 10px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h2>üó∫Ô∏è Image Georeferencing Tool</h2>
        
        <div class="instructions">
            <strong>Instructions:</strong> Upload image ‚Üí Drag to move ‚Üí Use corners to resize ‚Üí Rotate ‚Üí Export
        </div>
        
        <div class="reference-info">
            <strong>üìç All Images from index.js Loaded:</strong> The map shows the exact same base as index.html. Position your new image relative to these.
        </div>
        
        <div class="control-group">
            <label>Upload New Image:</label>
            <div class="control-row">
                <input type="file" id="imageUpload" accept="image/*">
                <button onclick="removeImage()" class="danger">Remove</button>
            </div>
        </div>
        
        <div class="control-group">
            <label>Image Opacity:</label>
            <div class="control-row">
                <input type="range" id="opacitySlider" min="0" max="1" step="0.1" value="0.8">
                <span id="opacityValue">0.8</span>
            </div>
        </div>
        
        <div class="control-group">
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="preserveAspectRatio" checked style="cursor: pointer;">
                <span>Preserve Aspect Ratio</span>
            </label>
        </div>
        
        <div class="control-group">
            <label>Rotation (degrees):</label>
            <div class="control-row">
                <input type="range" id="rotationSlider" min="0" max="360" step="1" value="0">
                <span id="rotationValue">0</span>
            </div>
        </div>
    </div>
    
    <div id="map"></div>
    
    <div id="coordinates-output">
        <button onclick="exportAndCopy()" class="copy-button">üìã Export & Copy Coordinates</button>
    </div>
    
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin="">
    </script>
    
    <script>
        // ===========================================
        // EXACT COPY FROM INDEX.JS - MAP INITIALIZATION
        // ===========================================
        
        // Initialize map
        const map = L.map('map').setView([37.368567140269306, -121.87689414145946], 18);

        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
            maxZoom: 21
        }).addTo(map);

        // Function to load and create overlays from JSON
        function loadOverlaysFromJSON(jsonUrl, map) {
            fetch(jsonUrl)
                .then(response => response.json())
                .then(data => {
                    data.overlays.forEach(overlayData => {
                        createImageOverlay(overlayData, map);
                    });
                })
                .catch(error => {
                    console.error('Error loading overlays:', error);
                });
        }

        // Constructor function to create individual overlay
        function createImageOverlay(overlayData, map) {
            var imageBounds = [
                overlayData.bounds.northEast,
                overlayData.bounds.southWest
            ];
            
            var imageOverlay = L.imageOverlay(overlayData.imageUrl, imageBounds, {
                opacity: 1,
                interactive: false  // Changed to false for reference
            }).addTo(map);
            
            // Audio removed for tool
            
            return imageOverlay;
        }

        // Usage: Load all overlays
        loadOverlaysFromJSON('assets/data/overlays.json', map);

        // Function to create an interactive overlay from data
        function createInteractiveOverlay(overlayData, map) {
            var imageBounds = [
                overlayData.bounds.northEast,
                overlayData.bounds.southWest
            ];
            
            var imageOverlay = L.imageOverlay(overlayData.mapImageUrl, imageBounds, {
                opacity: 1,
                interactive: false,  // Changed to false for reference
                className: 'custom-overlay-shadow'
            }).addTo(map);
            
            // Popup removed for tool
            
            return imageOverlay;
        }

        // Load and create all interactive overlays from JSON
        function loadInteractiveOverlays(jsonUrl, map) {
            fetch(jsonUrl)
                .then(response => response.json())
                .then(data => {
                    data.interactiveOverlays.forEach(overlayData => {
                        createInteractiveOverlay(overlayData, map);
                    });
                })
                .catch(error => {
                    console.error('Error loading interactive overlays:', error);
                });
        }

        // Load the interactive overlays
        loadInteractiveOverlays('assets/data/interactive-overlays.json', map);

        var imageUrlInter = 'https://res.cloudinary.com/do0ehwhde/image/upload/v1771279957/Picture1_cnopt5.jpg',
            imageBoundsInter = [[37.37572907, -121.88927114], [37.37307943, -121.88712537]];

        var imageInter = L.imageOverlay(imageUrlInter, imageBoundsInter, {
            opacity: 1,
            interactive: false
        }).addTo(map);

        var imageUrlInter2 = 'https://res.cloudinary.com/do0ehwhde/image/upload/v1771279962/Picture2_bwyyrm.jpg',
            imageBoundsInter2 = [[37.37572907, -121.88698537], [37.37307943, -121.88483960]];

        var imageInter2 = L.imageOverlay(imageUrlInter2, imageBoundsInter2, {
            opacity: 1,
            interactive: false
        }).addTo(map);

        var imageUrlInter3 = 'https://res.cloudinary.com/do0ehwhde/image/upload/v1771279968/Picture3_lakbgv.jpg',
            imageBoundsInter3 = [[37.37572907, -121.88469960], [37.37307943, -121.88255383]];

        var imageInter3 = L.imageOverlay(imageUrlInter3, imageBoundsInter3, {
            opacity: 1,
            interactive: false
        }).addTo(map);

        var imageUrlInter5 = 'https://res.cloudinary.com/do0ehwhde/image/upload/v1771026586/IMG_7_famvqv.jpg',
            imageBoundsInter5 = [[37.36816834, -121.88135058], [37.36759989, -121.88027769]];

        var imageUrlInter6 = 'https://res.cloudinary.com/do0ehwhde/image/upload/v1771026586/IMG_7_famvqv.jpg',
            imageBoundsInter6 = [[37.36735474, -121.88026428], [37.36645089, -121.87855840]];

        // Note: imageInter5 and imageInter6 variables exist but overlays not added to map in original
        
        // ===========================================
        // END OF INDEX.JS CODE
        // ===========================================
        
        // Dummy functions for reference controls (removed for simplicity)
        function toggleReferenceImages() {
            // All images from index.js are now part of the base map
            alert('All images from index.js are loaded. Use opacity slider on your new image.');
        }
        
        function adjustReferenceOpacity(opacity) {
            // Not applicable - base map images stay at original opacity
            alert('Base map images maintain their original opacity from index.js');
        }
        
        // NEW IMAGE UPLOAD AND POSITIONING CODE
        let imageContainer = null;
        let currentImage = null;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let isResizing = false;
        let resizeStart = { x: 0, y: 0, bounds: {} };
        let resizeCorner = null;
        let rotation = 0;
        
        let bounds = {
            pixelBounds: {
                x: 100,
                y: 100,
                width: 300,
                height: 200
            }
        };
        
        document.getElementById('imageUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    if (imageContainer) {
                        imageContainer.remove();
                    }
                    
                    currentImage = new Image();
                    currentImage.src = event.target.result;
                    
                    currentImage.onload = function() {
                        const mapCenter = map.getSize().divideBy(2);
                        const imageWidth = 300;
                        const imageHeight = (currentImage.naturalHeight / currentImage.naturalWidth) * imageWidth;
                        
                        bounds.pixelBounds = {
                            x: mapCenter.x - imageWidth / 2,
                            y: mapCenter.y - imageHeight / 2,
                            width: imageWidth,
                            height: imageHeight
                        };
                        
                        imageContainer = document.createElement('div');
                        imageContainer.className = 'image-overlay-container draggable';
                        imageContainer.style.position = 'absolute';
                        imageContainer.style.left = bounds.pixelBounds.x + 'px';
                        imageContainer.style.top = bounds.pixelBounds.y + 'px';
                        imageContainer.style.width = bounds.pixelBounds.width + 'px';
                        imageContainer.style.height = bounds.pixelBounds.height + 'px';
                        imageContainer.style.zIndex = '500';
                        imageContainer.style.opacity = '0.8';
                        imageContainer.style.border = '3px solid #d4d965';
                        imageContainer.style.boxShadow = '0 0 20px rgba(212, 217, 101, 0.8)';
                        
                        const img = document.createElement('img');
                        img.src = event.target.result;
                        imageContainer.appendChild(img);
                        
                        // Add to map container (NOT overlayPane!)
                        map.getContainer().appendChild(imageContainer);
                        
                        createCornerHandles();
                        
                        imageContainer.addEventListener('mousedown', startDrag);
                    };
                };
                reader.readAsDataURL(file);
            }
        });
        
        function createCornerHandles() {
            ['nw', 'ne', 'sw', 'se'].forEach(corner => {
                const handle = document.createElement('div');
                handle.className = 'corner-handle ' + corner;
                handle.dataset.corner = corner;
                imageContainer.appendChild(handle);
                
                handle.addEventListener('mousedown', function(e) {
                    e.stopPropagation();
                    startResize(e, corner);
                });
            });
            updateCornerHandles();
        }
        
        function updateCornerHandles() {
            if (!imageContainer) return;
            
            const handles = imageContainer.querySelectorAll('.corner-handle');
            const width = bounds.pixelBounds.width;
            const height = bounds.pixelBounds.height;
            
            handles.forEach(handle => {
                const corner = handle.dataset.corner;
                if (corner === 'nw') {
                    handle.style.left = '0px';
                    handle.style.top = '0px';
                } else if (corner === 'ne') {
                    handle.style.left = width + 'px';
                    handle.style.top = '0px';
                } else if (corner === 'sw') {
                    handle.style.left = '0px';
                    handle.style.top = height + 'px';
                } else if (corner === 'se') {
                    handle.style.left = width + 'px';
                    handle.style.top = height + 'px';
                }
            });
        }
        
        function startDrag(e) {
            if (e.target.classList.contains('corner-handle')) return;
            
            isDragging = true;
            dragStart = {
                x: e.clientX - bounds.pixelBounds.x,
                y: e.clientY - bounds.pixelBounds.y
            };
            map.dragging.disable();
            e.preventDefault();
        }
        
        function startResize(e, corner) {
            isResizing = true;
            resizeCorner = corner;
            resizeStart = {
                x: e.clientX,
                y: e.clientY,
                bounds: { ...bounds.pixelBounds }
            };
            map.dragging.disable();
            e.preventDefault();
        }
        
        document.addEventListener('mousemove', function(e) {
            if (isDragging && imageContainer) {
                bounds.pixelBounds.x = e.clientX - dragStart.x;
                bounds.pixelBounds.y = e.clientY - dragStart.y;
                imageContainer.style.left = bounds.pixelBounds.x + 'px';
                imageContainer.style.top = bounds.pixelBounds.y + 'px';
                updateCornerHandles();
            }
            
            if (isResizing && imageContainer) {
                const dx = e.clientX - resizeStart.x;
                const dy = e.clientY - resizeStart.y;
                
                const centerX = resizeStart.bounds.x + resizeStart.bounds.width / 2;
                const centerY = resizeStart.bounds.y + resizeStart.bounds.height / 2;
                
                const preserveAspect = document.getElementById('preserveAspectRatio').checked;
                
                if (preserveAspect && currentImage) {
                    const aspectRatio = currentImage.naturalWidth / currentImage.naturalHeight;
                    
                    let newWidth = resizeStart.bounds.width;
                    let newHeight = resizeStart.bounds.height;
                    
                    if (resizeCorner.includes('e')) newWidth += dx;
                    if (resizeCorner.includes('w')) newWidth -= dx;
                    if (resizeCorner.includes('s')) newHeight += dy;
                    if (resizeCorner.includes('n')) newHeight -= dy;
                    
                    const widthChange = Math.abs(newWidth - resizeStart.bounds.width);
                    const heightChange = Math.abs(newHeight - resizeStart.bounds.height);
                    
                    if (widthChange > heightChange) {
                        newHeight = newWidth / aspectRatio;
                    } else {
                        newWidth = newHeight * aspectRatio;
                    }
                    
                    bounds.pixelBounds.width = Math.max(50, newWidth);
                    bounds.pixelBounds.height = Math.max(50, newHeight);
                } else {
                    let newWidth = resizeStart.bounds.width;
                    let newHeight = resizeStart.bounds.height;
                    
                    if (resizeCorner.includes('e')) newWidth += dx;
                    if (resizeCorner.includes('w')) newWidth -= dx;
                    if (resizeCorner.includes('s')) newHeight += dy;
                    if (resizeCorner.includes('n')) newHeight -= dy;
                    
                    bounds.pixelBounds.width = Math.max(50, newWidth);
                    bounds.pixelBounds.height = Math.max(50, newHeight);
                }
                
                bounds.pixelBounds.x = centerX - bounds.pixelBounds.width / 2;
                bounds.pixelBounds.y = centerY - bounds.pixelBounds.height / 2;
                
                updateImageSize();
            }
        });
        
        document.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                map.dragging.enable();
            }
            if (isResizing) {
                isResizing = false;
                resizeCorner = null;
                map.dragging.enable();
            }
        });
        
        function updateImageSize() {
            if (imageContainer) {
                imageContainer.style.left = bounds.pixelBounds.x + 'px';
                imageContainer.style.top = bounds.pixelBounds.y + 'px';
                imageContainer.style.width = bounds.pixelBounds.width + 'px';
                imageContainer.style.height = bounds.pixelBounds.height + 'px';
                updateCornerHandles();
            }
        }
        
        document.getElementById('opacitySlider').addEventListener('input', function(e) {
            const opacity = parseFloat(e.target.value);
            document.getElementById('opacityValue').textContent = opacity.toFixed(1);
            if (imageContainer) {
                imageContainer.style.opacity = opacity;
            }
        });
        
        document.getElementById('rotationSlider').addEventListener('input', function(e) {
            rotation = parseFloat(e.target.value);
            document.getElementById('rotationValue').textContent = rotation;
            updateRotation();
        });
        
        function updateRotation() {
            if (imageContainer) {
                imageContainer.style.transform = `rotate(${rotation}deg)`;
                imageContainer.style.transformOrigin = 'center';
            }
        }
        
        function removeImage() {
            if (imageContainer) {
                imageContainer.remove();
                imageContainer = null;
            }
            currentImage = null;
        }
        
        async function exportAndCopy() {
            if (!imageContainer || !currentImage) {
                alert('Please upload an image first');
                return;
            }
            
            const opacity = parseFloat(document.getElementById('opacitySlider').value);
            
            if (rotation !== 0) {
                // Rotation applied - export rotated image
                
                // Use original image dimensions for high resolution export
                const originalWidth = currentImage.naturalWidth;
                const originalHeight = currentImage.naturalHeight;
                const radians = (rotation * Math.PI) / 180;
                
                // Calculate bounding box of rotated rectangle at original resolution
                const cos = Math.abs(Math.cos(radians));
                const sin = Math.abs(Math.sin(radians));
                const newWidth = Math.ceil(originalWidth * cos + originalHeight * sin);
                const newHeight = Math.ceil(originalWidth * sin + originalHeight * cos);
                
                // Create canvas with expanded size at original resolution
                const canvas = document.createElement('canvas');
                canvas.width = newWidth;
                canvas.height = newHeight;
                const ctx = canvas.getContext('2d');
                
                // Enable high quality rendering
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                // Make background transparent
                ctx.clearRect(0, 0, newWidth, newHeight);
                
                // Draw rotated image centered in expanded canvas at original resolution
                ctx.translate(newWidth / 2, newHeight / 2);
                ctx.rotate(radians);
                ctx.drawImage(currentImage, -originalWidth / 2, -originalHeight / 2, originalWidth, originalHeight);
                
                // Convert to data URL with high quality
                const rotatedImageData = canvas.toDataURL('image/png', 1.0);
                
                // Calculate lat/lng bounds based on screen display position
                const centerX = bounds.pixelBounds.x + bounds.pixelBounds.width / 2;
                const centerY = bounds.pixelBounds.y + bounds.pixelBounds.height / 2;
                
                // Calculate screen size of expanded bounding box
                const screenWidth = bounds.pixelBounds.width;
                const screenHeight = bounds.pixelBounds.height;
                const screenNewWidth = Math.ceil(screenWidth * cos + screenHeight * sin);
                const screenNewHeight = Math.ceil(screenWidth * sin + screenHeight * cos);
                
                // The expanded bounding box in screen space
                const nwX = centerX - screenNewWidth / 2;
                const nwY = centerY - screenNewHeight / 2;
                const seX = centerX + screenNewWidth / 2;
                const seY = centerY + screenNewHeight / 2;
                
                // Convert to lat/lng
                const nw = map.containerPointToLatLng([nwX, nwY]);
                const se = map.containerPointToLatLng([seX, seY]);
                
                // Generate code
                const code = `[[${nw.lat.toFixed(8)}, ${nw.lng.toFixed(8)}], [${se.lat.toFixed(8)}, ${se.lng.toFixed(8)}]]`;
                
                // Copy to clipboard
                await navigator.clipboard.writeText(code);
                
                // Download rotated image
                const link = document.createElement('a');
                link.download = 'georeferenced_image.png';
                link.href = rotatedImageData;
                link.click();
                
                // Show success
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '‚úì Exported & Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
                
            } else {
                // No rotation - just output code, no image download
                
                // Calculate lat/lng bounds from screen position
                const nw = map.containerPointToLatLng([bounds.pixelBounds.x, bounds.pixelBounds.y]);
                const se = map.containerPointToLatLng([
                    bounds.pixelBounds.x + bounds.pixelBounds.width,
                    bounds.pixelBounds.y + bounds.pixelBounds.height
                ]);
                
                // Generate code
                const code = `[[${nw.lat.toFixed(8)}, ${nw.lng.toFixed(8)}], [${se.lat.toFixed(8)}, ${se.lng.toFixed(8)}]]`;
                
                // Copy to clipboard
                await navigator.clipboard.writeText(code);
                
                // Show success (no download)
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '‚úì Code Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            }
        }
    </script>
</body>
</html>
